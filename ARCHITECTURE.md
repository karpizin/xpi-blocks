# Архитектура XPI-Blocks

Библиотека построена на принципах модульности, типизации и абстракции от конкретного железа.

## 1. Стандарты написания нод (Tiered Node Architecture)

Все ноды делятся на три уровня сложности:
1.  **Simple Nodes**: Простые обертки над `gpiozero`, публикующие данные в топик.
2.  **Lifecycle Nodes**: Ноды с управляемым состоянием (Managed Nodes) для критических систем.
3.  **Complex Nodes**: Ноды с внутренней бизнес-логикой (например, `GaitEngine`).

## 2. Hardware Abstraction Layer (HAL)

Мы используем стандартные библиотеки Python для работы с шинами данных:
*   **I2C**: `smbus2` или `Adafruit-Blinka` (CircuitPython API).
*   **GPIO**: `gpiozero` (предпочтительно) или `lgpio`.
*   **SPI**: `spidev`.

**Mocking**: Для тестирования на ПК без Raspberry Pi используется `GPIOZERO_PIN_FACTORY=mock`.

## 3. Проекты (Case Studies)

### Hexapod Master
Реализует полный стек управления шестиногим роботом:
*   **Kinematics Node**: Рассчитывает положение корпуса (roll/pitch/yaw) и транслирует в углы сервоприводов.
*   **Gait Node**: Генератор походки. Поддерживает режимы:
    *   `Tripod`: Баланс скорости и стабильности.
    *   `Wave`: Максимальная стабильность (одна нога в воздухе).
    *   `Ripple`: Компромиссный вариант для сложного рельефа.
*   **Auto-Leveler**: Использование данных IMU для удержания горизонта корпуса.

## 4. Система индикации (USIS)

Universal Status Indication System (USIS) определяет стандарт световых сигналов для робота:
*   **Blue Pulsing**: Инициализация / Ожидание.
*   **Green Constant**: Готов к работе.
*   **Red Blinking**: Критическая ошибка.
*   **Yellow Rotating**: Работа AI / Анализ.

## 5. Интеграция с ИИ

Пакет `xpi_llm` обеспечивает мост между ROS2 и облачными LLM:
*   **Tool Calling**: ИИ может сам вызывать ROS-сервисы (например, "осмотрись" ➔ вызов поворота головы).
*   **Context Injection**: Данные с датчиков (температура, дистанция) упаковываются в промпт для принятия решений.